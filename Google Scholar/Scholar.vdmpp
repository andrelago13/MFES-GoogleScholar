class Scholar
	types
	
	values
	
	instance variables
		private users: set of User := {};
		private papers: set of Paper := {};
		private people: set of Person := {};
		private currentUser: [User] := nil;
		
	operations
		public pure getUserByEmail: Utils`String ==> [User]
		getUserByEmail(e) == (
			for all u in set users do
				if (u.getEmail() = e) then
					return u;
			return nil;
		);
		
		public login: Utils`String * Utils`String ==> ()
		login(e, p) == (
			dcl u: [User] := getUserByEmail(e);
			if u <> nil and u.isValidPassword(p) then (
				currentUser := u;
			)
		)
		pre not isLoggedIn()
		post let u = getUserByEmail(e) in (
				(not isLoggedIn() and u = nil)
				or (not isLoggedIn() and not u.isValidPassword(p))
				or (currentUser = u and u.getEmail() = e and u.isValidPassword(p))
			);
			
		public logout: () ==> ()
		logout() == (
			currentUser := nil;
		)
		pre isLoggedIn()
		post not isLoggedIn();
		
		public pure isLoggedIn: () ==> bool
		isLoggedIn() == (
			return currentUser <> nil;
		);
		
		public pure getCurrentUser: () ==> [User]
		getCurrentUser() == (
			return currentUser;
		);
		
		public register: Utils`String * Utils`String ==> ()
		register(e, p) == (
			users := users union {new User(e, p)};
		)
		pre getUserByEmail(e) = nil
		post getUserByEmail(e).isValidPassword(p);
		
		public getPapersFromAuthorName: Utils`String ==> set of Paper
		getPapersFromAuthorName(name) == (
			dcl author : Person := Person`getPersonByName(people, name);
			return Paper`papersFromAuthor(papers, author);
		);
		
		public addPaper: Paper ==> ()
		addPaper(paper) == (
			papers := papers union {paper};
			currentUser.addPaper(paper);
		)
		pre isLoggedIn() and paper not in set papers
		post paper in set papers;
	
	functions
		
	traces
	
end Scholar