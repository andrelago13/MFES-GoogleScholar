class User
	types
	
	values
	
	instance variables
		public email: Utils`String := [];
		public password: Utils`String := [];
		public papers: set of Paper := {};
		
	operations	
		public User: Utils`String * Utils`String  ==> User
		User(e, p) == (
			email := e;
			password := p;
			return self;
		);
		
		public pure getEmail: () ==> Utils`String
		getEmail() ==
			return email;
			
		public pure isValidPassword: Utils`String ==> bool
		isValidPassword(p) == (
			return isMatchingPassword(p, password);
		);
		
		public changePassword: Utils`String ==> ()
		changePassword(newPassword) == (
			password := newPassword;
		)post password~ <> password;
		
		public addPaper: Paper ==> ()
		addPaper(paper) == (
			papers := papers union {paper};
		)
		pre paper not in set papers
		post paper in set papers;
		
		public removePaper: Paper ==> ()
		removePaper(paper) == (
			papers := papers \ {paper};
		)
		pre paper in set papers
		post papers = papers~ \ {paper}; 
		
		public pure getPapers: () ==> set of Paper
		getPapers() ==
			return papers;
			
		public pure getHIndex: set of Paper ==> nat
		getHIndex(allPapers) == (
			dcl scores : seq of nat := [];
			
			for all p in set papers do (
				scores := scores ^ [p.getNumCitedBy(allPapers)];
			);
			scores := Utils`Mergesort(scores);
			
			return Utils`GetHIndex(scores);
		);
			
		public pure getI10Index: set of Paper ==> nat
		getI10Index(allPapers) == (
			dcl result : nat := 0;
			
			for all p in set papers do (
				if (p.getNumCitedBy(allPapers) >= 10) then (
					result := result + 1;
				)
			);
			
			return result;
		);
	
	functions
		static public isMatchingPassword: Utils`String * Utils`String -> bool
		isMatchingPassword(p1, p2) == (
			p1 = p2
		);
	
	traces
	
end User