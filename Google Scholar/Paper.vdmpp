class Paper
	types
	-- TODO Define types here
	values
	-- TODO Define values here
	instance variables
		public abstract: Utils`String := [];
		public publicationDate: Date := new Date(2016,2,2);
		public DOI: Utils`String := [];
		authors: set of Person := {};
		cites: set of Paper := {};
		relatedTo: set of Paper := {};
		
		inv card authors > 0; -- pelo menos um autor
		
	operations
		public Paper: Utils`String * Date * Utils`String * Person ==> Paper
		Paper(ab, pubDate, doi, author) == (
			abstract := ab;
			publicationDate := pubDate;
			DOI := doi;
			authors := {author};
			return self
		);
			
		public Paper: Utils`String * Date * Utils`String * set of Person ==> Paper
		Paper(ab, pubDate, doi, authrs) == (
			abstract := ab;
			publicationDate := pubDate;
			DOI := doi;
			authors := authrs;
			return self
		);
			
		public getAuthors: () ==> set of Person
		getAuthors() == (
			return authors;
		)
		post authors = authors~;
			
		public getCitations: () ==> set of Paper
		getCitations() == (
			return cites;
		)
		post cites = cites~;
			
		public getRelatedPapers: () ==> set of Paper
		getRelatedPapers() == (
			return relatedTo;
		)
		post relatedTo = relatedTo~;
			
		public addCitation(p: Paper) == if self <> p then cites := cites union {p}
		post cites = cites~ union {p};
			
		public addRelatedPaper(p: Paper) == if self <> p then relatedTo := relatedTo union {p}
		post relatedTo = relatedTo~ union {p};
		
		static public papersFromAuthor: set of Paper * Person ==> set of Paper
		papersFromAuthor(papers, author) == (
			dcl res : set of Paper := {};
			for all p in set papers do
				if(author in set p.getAuthors()) then
					res := res union {p};
			return res
		)
		
	functions
	-- TODO Define functiones here
	traces
	-- TODO Define Combinatorial Test Traces here
end Paper