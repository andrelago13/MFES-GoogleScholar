class Paper
	types
	-- TODO Define types here
	values
	-- TODO Define values here
	instance variables
		public abstract: ScholarUtils`String := [];
		public publicationDate: nat;
		public DOI: ScholarUtils`String := [];
		public title: ScholarUtils`String := [];
		authors: set of ScholarUtils`String := {};
		cites: set of Paper := {}; --nao mudar
		relatedTo: set of Paper := {}; --nao mudar
		
		inv card authors > 0; -- pelo menos um autor
		inv not inCitations();
		inv not inRelated();
		
	operations
		public Paper: ScholarUtils`String * nat * ScholarUtils`String * ScholarUtils`String * ScholarUtils`String ==> Paper
		Paper(ab, pubDate, t, doi, author) == (
			abstract := ab;
			publicationDate := pubDate;
			title := t;
			DOI := doi;
			authors := {author};
			return self
		);
		
		private pure inCitations: () ==> bool
		inCitations() == (
			return self in set cites;
		);
		
		private pure inRelated: () ==> bool
		inRelated() == (
			return self in set relatedTo;
		);
		
		public changeAbstract: ScholarUtils`String ==> ()
		changeAbstract(newAbstract) == (
			abstract := newAbstract;
		)post abstract = newAbstract;
		
		public changePublicationDate: nat ==> ()
		changePublicationDate(newPublicationDate) == (
			publicationDate := newPublicationDate;
		)post publicationDate = newPublicationDate;
		
		public changeTitle: ScholarUtils`String ==> ()
		changeTitle(newTitle) == (
			title := newTitle;
		)post title = newTitle;
		
		public changeDOI: ScholarUtils`String ==> ()
		changeDOI(newDOI) == (
			DOI := newDOI;
		)post DOI = newDOI;
		
		public changeAuthors: set of ScholarUtils`String ==> ()
		changeAuthors(newAuthors) == (
			authors := newAuthors;
		)post authors = newAuthors;
			
		public Paper: ScholarUtils`String * nat * ScholarUtils`String * ScholarUtils`String * set of ScholarUtils`String ==> Paper
		Paper(ab, pubDate, t, doi, authrs) == (
			abstract := ab;
			publicationDate := pubDate;
			title := t;
			DOI := doi;
			authors := authrs;
			return self
		);
		
		public pure getAbstract: () ==> ScholarUtils`String
		getAbstract() == (
			return abstract;
		);
			
		public pure getAuthors: () ==> set of ScholarUtils`String
		getAuthors() == (
			return authors;
		);
		
		public pure getTitle: () ==> ScholarUtils`String
		getTitle() == (
			return title;
		);
		
		public pure getPublicationDate: () ==> nat
		getPublicationDate() == (
			return publicationDate;
		);
		
		public pure getDOI: () ==> ScholarUtils`String
		getDOI() == (
			return DOI;
		);
			
		public pure getCitations: () ==> set of Paper
		getCitations() == (
			return cites;
		);
			
		public pure getRelatedPapers: () ==> set of Paper
		getRelatedPapers() == (
			return relatedTo;
		);
			
		public addCitation: Paper ==> ()
		addCitation(p) == (
			cites := cites union {p}
		)
		pre self <> p -- no paper should cite itself
		post cites = cites~ union {p};
			
		public addRelatedPaper: Paper ==> ()
		addRelatedPaper(p) == (
			relatedTo := relatedTo union {p}
		)
		pre self <> p -- a paper should not be related to itself
		post relatedTo = relatedTo~ union {p};
		
		-- number of papers from "papers" that cite this paper
		public pure getNumCitedBy: set of Paper ==> nat
		getNumCitedBy(papers) == (
			dcl res :  nat := 0;
			for all p in set papers do
				if(self in set p.getCitations()) then
					res := res + 1;
			return res;
		);
		
		static public papersFromAuthor: set of Paper * ScholarUtils`String ==> set of Paper
		papersFromAuthor(papers, author) == (
			dcl res : set of Paper := {};
			for all p in set papers do
				if(author in set p.getAuthors()) then
					res := res union {p};
			return res
		)
		post forall p in set RESULT & author in set p.authors;
		
	functions
	-- TODO Define functiones here
	traces
	-- TODO Define Combinatorial Test Traces here
end Paper